package main

import (
	"fmt"
	"io"
	"log"
	"math"
	"os"
	"runtime/pprof"
	"sort"

	"github.com/diamondburned/aoc-2022/aocutil"
)

func main() {
	m := make(Map)

	input := aocutil.InputString()
	lines := aocutil.SplitLines(input)
	for _, line := range lines {
		const fstr = "Sensor at x=%d, y=%d: closest beacon is at x=%d, y=%d"
		var sensorAt, beaconAt Pt
		aocutil.Sscanf(line, fstr, &sensorAt.X, &sensorAt.Y, &beaconAt.X, &beaconAt.Y)

		// 		sensorAt.X *= 1000
		// 		sensorAt.Y *= 1000
		// 		beaconAt.X *= 1000
		// 		beaconAt.Y *= 1000

		m[beaconAt] = Beacon{}
		m[sensorAt] = Sensor{
			NearestBeacon:  beaconAt,
			BeaconDistance: mdist(sensorAt, beaconAt),
		}
	}

	{
		f, err := os.Create("/tmp/cpuprofile.pprof")
		if err != nil {
			log.Fatal("could not create CPU profile: ", err)
		}
		defer f.Close()

		if err := pprof.StartCPUProfile(f); err != nil {
			log.Fatal("could not start CPU profile: ", err)
		}
		defer pprof.StopCPUProfile()
	}

	// part1(m, 2_000_000)
	part2(m, 4_000_000)
	// part2(m, 20000)
	// part2(m, 20)
}

func part1(m Map, y int64) {
	sensors := m.NearbySensorsForRow(y)
	beacons := m.BeaconsAtRow(y)

	beaconMap := aocutil.NewSet[int64](len(beacons))
	for _, pt := range beacons {
		beaconMap[pt.At.X] = struct{}{}
	}

	minX := int64(math.MaxInt64)
	maxX := int64(math.MinInt64)

	// We need to find the minumum and maximum X that our sensors cover from the
	// wanted y.
	for _, sensor := range sensors {
		minX = aocutil.Min2(minX, sensor.At.X-sensor.Data.BeaconDistance)
		maxX = aocutil.Max2(maxX, sensor.At.X+sensor.Data.BeaconDistance)
	}

	coverage := aocutil.NewSet[int64](int(maxX - minX))
	for x := minX; x <= maxX; x++ {
		if beaconMap.Has(x) {
			continue
		}

		for _, sensor := range sensors {
			if sensorCovers(sensor, Pt{x, y}) {
				coverage[x] = struct{}{}
				break
			}
		}
	}

	var count int64
	for range coverage {
		count++
	}
	fmt.Println("part 1:", count)
}

// sensorCovers returns true if the given point64 is within the region that covers
// from the sensor to the nearest beacon.
func sensorCovers(sensor MapPt[Sensor], pt Pt) bool {
	d1 := mdist(sensor.At, pt)
	d2 := sensor.Data.BeaconDistance
	return d1 <= d2
}

func part2(m Map, max int64) {
	type coverageType uint8

	const (
		_ coverageType = iota
		hasCoverage
		hasBeacon
	)

	var distressPos Pt
	coverage := make([]coverageType, max+1)

	// beacons will be a map of Y values to a list of X values that have a
	// beacon. Each index will represent the Y value.
	beacons := make(map[int64][]int64, max+1)
	for pt, data := range m {
		if _, ok := data.(Beacon); ok && 0 <= pt.X && pt.X <= max {
			beacons[pt.Y] = append(beacons[pt.Y], pt.X)
		}
	}

	sensors := make([]MapPt[Sensor], 0, len(m))
	for pt, data := range m {
		if sensor, ok := data.(Sensor); ok && 0 <= pt.X && pt.X <= max {
			sensors = append(sensors, MapPt[Sensor]{pt, sensor})
		}
	}

	// Sort so that the sensors with the largest Y are first.
	sort.Slice(sensors, func(i, j int) bool {
		return sensors[i].Data.BeaconDistance > sensors[j].Data.BeaconDistance
	})

	log.Println("min distance:", sensors[len(sensors)-1].Data.BeaconDistance)
	log.Println("max distance:", sensors[0].Data.BeaconDistance)
	for i, sensor := range sensors {
		log.Println(i, sensor.At, "distance:", sensor.Data.BeaconDistance)
	}

	populateCoverage := func(y int64) {
		for i := range coverage {
			coverage[i] = 0
		}

		// Precalculate the coverage for this row.
		for _, sensor := range sensors {
			// We can use a trick here: we can calculate how much coverage a
			// single sensor has for a single row by subtracting its maximum
			// distance to our Y, both of which are already calculated.
			yDist := abs(y - sensor.At.Y)
			if sensor.Data.BeaconDistance < yDist {
				continue
			}

			xDist := sensor.Data.BeaconDistance - yDist
			x1 := aocutil.Max2(sensor.At.X-xDist, 0)
			x2 := aocutil.Min2(sensor.At.X+xDist, max)
			for x := x1; x <= x2; x++ {
				coverage[x] = hasCoverage
			}
		}

		// Find the beacons at this row.
		if xs, ok := beacons[y]; ok {
			for _, x := range xs {
				coverage[x] = hasBeacon
			}
		}
	}

	// Get the minimum distance. We can search Y faster by using this.
	minDistance := sensors[len(sensors)-1].Data.BeaconDistance
search:
	for y := int64(0); y < max; y += minDistance / 2 {
		populateCoverage(y)
		// fmt.Println(coverage)

		var hasGap bool
		for _, d := range coverage {
			if d == 0 {
				hasGap = true
				break
			}
		}

		if !hasGap {
			continue search
		}

		log.Println("found a gap at Y:", y, "searching for a beacon")

		// owo?? We should search more of y here.
		for y := y - minDistance; y < y+minDistance; y++ {
			populateCoverage(y)
			for x, d := range coverage {
				if d == 0 {
					distressPos = Pt{int64(x), y}
					break search
				}
			}
		}
	}

	fmt.Println("part 2:", tuningFreq(distressPos), distressPos)
}

const distressC = 4_000_000

func tuningFreq(pt Pt) int64 {
	return (pt.X * distressC) + pt.Y
}

type Pt struct{ X, Y int64 }

type Map map[Pt]Data

type MapPt[T Data] struct {
	At   Pt
	Data T
}

func (m Map) DrawMap(w io.Writer, start, end Pt) {
	for y := start.Y; y <= end.Y; y++ {
		for x := start.X; x <= end.X; x++ {
			p := Pt{x, y}
			if data, ok := m[p]; ok {
				w.Write([]byte{data.Data()})
			} else {
				w.Write([]byte("."))
			}
		}
		w.Write([]byte{'\n'})
	}
}

// NearbySensorsForRow returns the list of coordinates of the sensors that are
// near the given row. A sensor is near if its signal reaches the given row.
func (m Map) NearbySensorsForRow(y int64) []MapPt[Sensor] {
	var pts []MapPt[Sensor]
	for pt, data := range m {
		if sensor, ok := data.(Sensor); ok {
			if pt.Y-sensor.BeaconDistance <= y && y <= pt.Y+sensor.BeaconDistance {
				pts = append(pts, MapPt[Sensor]{pt, sensor})
			}
		}
	}
	return pts
}

// BeaconsAtRow returns the list of coordinates of the beacons that are at the
// given row.
func (m Map) BeaconsAtRow(y int64) []MapPt[Beacon] {
	var pts []MapPt[Beacon]
	for pt, data := range m {
		if beacon, ok := data.(Beacon); ok && pt.Y == y {
			pts = append(pts, MapPt[Beacon]{pt, beacon})
		}
	}
	return pts
}

type Data interface {
	Data() byte
}

func (Beacon) Data() byte { return 'B' }
func (Sensor) Data() byte { return 'S' }

type Beacon struct{}

type Sensor struct {
	NearestBeacon  Pt
	BeaconDistance int64
}

func mdist(a, b Pt) int64 {
	return abs(a.X-b.X) + abs(a.Y-b.Y)
}

func abs(n int64) int64 {
	if n < 0 {
		return -n
	}
	return n
}
